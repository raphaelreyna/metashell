// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package daemon

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ShellclientDaemonClient is the client API for ShellclientDaemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShellclientDaemonClient interface {
	PreRunQuery(ctx context.Context, in *PreRunQueryRequest, opts ...grpc.CallOption) (*PreRunQueryResponse, error)
	PostRunReport(ctx context.Context, in *PostRunReportRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type shellclientDaemonClient struct {
	cc grpc.ClientConnInterface
}

func NewShellclientDaemonClient(cc grpc.ClientConnInterface) ShellclientDaemonClient {
	return &shellclientDaemonClient{cc}
}

func (c *shellclientDaemonClient) PreRunQuery(ctx context.Context, in *PreRunQueryRequest, opts ...grpc.CallOption) (*PreRunQueryResponse, error) {
	out := new(PreRunQueryResponse)
	err := c.cc.Invoke(ctx, "/shelld.daemon.ShellclientDaemon/PreRunQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shellclientDaemonClient) PostRunReport(ctx context.Context, in *PostRunReportRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/shelld.daemon.ShellclientDaemon/PostRunReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShellclientDaemonServer is the server API for ShellclientDaemon service.
// All implementations must embed UnimplementedShellclientDaemonServer
// for forward compatibility
type ShellclientDaemonServer interface {
	PreRunQuery(context.Context, *PreRunQueryRequest) (*PreRunQueryResponse, error)
	PostRunReport(context.Context, *PostRunReportRequest) (*empty.Empty, error)
	mustEmbedUnimplementedShellclientDaemonServer()
}

// UnimplementedShellclientDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedShellclientDaemonServer struct {
}

func (UnimplementedShellclientDaemonServer) PreRunQuery(context.Context, *PreRunQueryRequest) (*PreRunQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreRunQuery not implemented")
}
func (UnimplementedShellclientDaemonServer) PostRunReport(context.Context, *PostRunReportRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostRunReport not implemented")
}
func (UnimplementedShellclientDaemonServer) mustEmbedUnimplementedShellclientDaemonServer() {}

// UnsafeShellclientDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShellclientDaemonServer will
// result in compilation errors.
type UnsafeShellclientDaemonServer interface {
	mustEmbedUnimplementedShellclientDaemonServer()
}

func RegisterShellclientDaemonServer(s grpc.ServiceRegistrar, srv ShellclientDaemonServer) {
	s.RegisterService(&ShellclientDaemon_ServiceDesc, srv)
}

func _ShellclientDaemon_PreRunQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreRunQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShellclientDaemonServer).PreRunQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shelld.daemon.ShellclientDaemon/PreRunQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShellclientDaemonServer).PreRunQuery(ctx, req.(*PreRunQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShellclientDaemon_PostRunReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostRunReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShellclientDaemonServer).PostRunReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shelld.daemon.ShellclientDaemon/PostRunReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShellclientDaemonServer).PostRunReport(ctx, req.(*PostRunReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShellclientDaemon_ServiceDesc is the grpc.ServiceDesc for ShellclientDaemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShellclientDaemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shelld.daemon.ShellclientDaemon",
	HandlerType: (*ShellclientDaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PreRunQuery",
			Handler:    _ShellclientDaemon_PreRunQuery_Handler,
		},
		{
			MethodName: "PostRunReport",
			Handler:    _ShellclientDaemon_PostRunReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "daemon/daemon.proto",
}

// MetashellDaemonClient is the client API for MetashellDaemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetashellDaemonClient interface {
	NewExitCodeStream(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (MetashellDaemon_NewExitCodeStreamClient, error)
	RegisterCommandEntry(ctx context.Context, in *CommandEntry, opts ...grpc.CallOption) (*CommandKey, error)
	Metacommand(ctx context.Context, in *MetacommandRequest, opts ...grpc.CallOption) (*MetacommandResponse, error)
	GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error)
}

type metashellDaemonClient struct {
	cc grpc.ClientConnInterface
}

func NewMetashellDaemonClient(cc grpc.ClientConnInterface) MetashellDaemonClient {
	return &metashellDaemonClient{cc}
}

func (c *metashellDaemonClient) NewExitCodeStream(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (MetashellDaemon_NewExitCodeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &MetashellDaemon_ServiceDesc.Streams[0], "/shelld.daemon.MetashellDaemon/NewExitCodeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &metashellDaemonNewExitCodeStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MetashellDaemon_NewExitCodeStreamClient interface {
	Recv() (*CommandExitCode, error)
	grpc.ClientStream
}

type metashellDaemonNewExitCodeStreamClient struct {
	grpc.ClientStream
}

func (x *metashellDaemonNewExitCodeStreamClient) Recv() (*CommandExitCode, error) {
	m := new(CommandExitCode)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metashellDaemonClient) RegisterCommandEntry(ctx context.Context, in *CommandEntry, opts ...grpc.CallOption) (*CommandKey, error) {
	out := new(CommandKey)
	err := c.cc.Invoke(ctx, "/shelld.daemon.MetashellDaemon/RegisterCommandEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metashellDaemonClient) Metacommand(ctx context.Context, in *MetacommandRequest, opts ...grpc.CallOption) (*MetacommandResponse, error) {
	out := new(MetacommandResponse)
	err := c.cc.Invoke(ctx, "/shelld.daemon.MetashellDaemon/Metacommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metashellDaemonClient) GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error) {
	out := new(GetPluginInfoResponse)
	err := c.cc.Invoke(ctx, "/shelld.daemon.MetashellDaemon/GetPluginInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetashellDaemonServer is the server API for MetashellDaemon service.
// All implementations must embed UnimplementedMetashellDaemonServer
// for forward compatibility
type MetashellDaemonServer interface {
	NewExitCodeStream(*empty.Empty, MetashellDaemon_NewExitCodeStreamServer) error
	RegisterCommandEntry(context.Context, *CommandEntry) (*CommandKey, error)
	Metacommand(context.Context, *MetacommandRequest) (*MetacommandResponse, error)
	GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error)
	mustEmbedUnimplementedMetashellDaemonServer()
}

// UnimplementedMetashellDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedMetashellDaemonServer struct {
}

func (UnimplementedMetashellDaemonServer) NewExitCodeStream(*empty.Empty, MetashellDaemon_NewExitCodeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method NewExitCodeStream not implemented")
}
func (UnimplementedMetashellDaemonServer) RegisterCommandEntry(context.Context, *CommandEntry) (*CommandKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCommandEntry not implemented")
}
func (UnimplementedMetashellDaemonServer) Metacommand(context.Context, *MetacommandRequest) (*MetacommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metacommand not implemented")
}
func (UnimplementedMetashellDaemonServer) GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginInfo not implemented")
}
func (UnimplementedMetashellDaemonServer) mustEmbedUnimplementedMetashellDaemonServer() {}

// UnsafeMetashellDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetashellDaemonServer will
// result in compilation errors.
type UnsafeMetashellDaemonServer interface {
	mustEmbedUnimplementedMetashellDaemonServer()
}

func RegisterMetashellDaemonServer(s grpc.ServiceRegistrar, srv MetashellDaemonServer) {
	s.RegisterService(&MetashellDaemon_ServiceDesc, srv)
}

func _MetashellDaemon_NewExitCodeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetashellDaemonServer).NewExitCodeStream(m, &metashellDaemonNewExitCodeStreamServer{stream})
}

type MetashellDaemon_NewExitCodeStreamServer interface {
	Send(*CommandExitCode) error
	grpc.ServerStream
}

type metashellDaemonNewExitCodeStreamServer struct {
	grpc.ServerStream
}

func (x *metashellDaemonNewExitCodeStreamServer) Send(m *CommandExitCode) error {
	return x.ServerStream.SendMsg(m)
}

func _MetashellDaemon_RegisterCommandEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetashellDaemonServer).RegisterCommandEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shelld.daemon.MetashellDaemon/RegisterCommandEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetashellDaemonServer).RegisterCommandEntry(ctx, req.(*CommandEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetashellDaemon_Metacommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetacommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetashellDaemonServer).Metacommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shelld.daemon.MetashellDaemon/Metacommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetashellDaemonServer).Metacommand(ctx, req.(*MetacommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetashellDaemon_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetashellDaemonServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shelld.daemon.MetashellDaemon/GetPluginInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetashellDaemonServer).GetPluginInfo(ctx, req.(*GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MetashellDaemon_ServiceDesc is the grpc.ServiceDesc for MetashellDaemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetashellDaemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shelld.daemon.MetashellDaemon",
	HandlerType: (*MetashellDaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCommandEntry",
			Handler:    _MetashellDaemon_RegisterCommandEntry_Handler,
		},
		{
			MethodName: "Metacommand",
			Handler:    _MetashellDaemon_Metacommand_Handler,
		},
		{
			MethodName: "GetPluginInfo",
			Handler:    _MetashellDaemon_GetPluginInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NewExitCodeStream",
			Handler:       _MetashellDaemon_NewExitCodeStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon/daemon.proto",
}
